"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/auth/register/page",{

/***/ "(app-pages-browser)/./lib/utils/otp.ts":
/*!**************************!*\
  !*** ./lib/utils/otp.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OTP_CONFIG: function() { return /* binding */ OTP_CONFIG; },\n/* harmony export */   createOTPData: function() { return /* binding */ createOTPData; },\n/* harmony export */   formatTimeRemaining: function() { return /* binding */ formatTimeRemaining; },\n/* harmony export */   generateOTP: function() { return /* binding */ generateOTP; },\n/* harmony export */   getTimeRemaining: function() { return /* binding */ getTimeRemaining; },\n/* harmony export */   isMaxAttemptsExceeded: function() { return /* binding */ isMaxAttemptsExceeded; },\n/* harmony export */   isOTPExpired: function() { return /* binding */ isOTPExpired; },\n/* harmony export */   maskEmail: function() { return /* binding */ maskEmail; },\n/* harmony export */   maskPhoneNumber: function() { return /* binding */ maskPhoneNumber; },\n/* harmony export */   sendOTPViaEmail: function() { return /* binding */ sendOTPViaEmail; },\n/* harmony export */   sendOTPViaSMS: function() { return /* binding */ sendOTPViaSMS; },\n/* harmony export */   validateOTP: function() { return /* binding */ validateOTP; }\n/* harmony export */ });\n/**\r\n * OTP Utility Service\r\n * Handles OTP generation, validation, and management\r\n * \r\n * In production, this would integrate with SMS/Email providers like:\r\n * - Twilio, MSG91, Firebase Auth, AWS SNS\r\n */ // OTP Configuration\nconst OTP_CONFIG = {\n    length: 6,\n    expiryMinutes: 5,\n    maxAttempts: 3,\n    resendCooldownSeconds: 30,\n    // Demo mode - in production, set to false\n    demoMode: true,\n    // Demo OTP for testing\n    demoOTP: \"123456\"\n};\n/**\r\n * Generate a random numeric OTP\r\n */ function generateOTP() {\n    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OTP_CONFIG.length;\n    if (OTP_CONFIG.demoMode) {\n        return OTP_CONFIG.demoOTP;\n    }\n    let otp = \"\";\n    for(let i = 0; i < length; i++){\n        otp += Math.floor(Math.random() * 10).toString();\n    }\n    return otp;\n}\n/**\r\n * Create OTP data object with expiry\r\n */ function createOTPData(channel, identifier, purpose) {\n    const now = Date.now();\n    return {\n        otp: generateOTP(),\n        phone: channel === \"sms\" ? identifier : undefined,\n        email: channel === \"email\" ? identifier : undefined,\n        channel,\n        createdAt: now,\n        expiresAt: now + OTP_CONFIG.expiryMinutes * 60 * 1000,\n        attempts: 0,\n        verified: false,\n        purpose\n    };\n}\n/**\r\n * Check if OTP is expired\r\n */ function isOTPExpired(otpData) {\n    return Date.now() > otpData.expiresAt;\n}\n/**\r\n * Check if max attempts exceeded\r\n */ function isMaxAttemptsExceeded(otpData) {\n    return otpData.attempts >= OTP_CONFIG.maxAttempts;\n}\n/**\r\n * Validate OTP\r\n */ function validateOTP(inputOTP, otpData) {\n    // Check if already verified\n    if (otpData.verified) {\n        return {\n            valid: false,\n            error: \"OTP already used\"\n        };\n    }\n    // Check expiry\n    if (isOTPExpired(otpData)) {\n        return {\n            valid: false,\n            error: \"OTP has expired. Please request a new one.\"\n        };\n    }\n    // Check attempts\n    if (isMaxAttemptsExceeded(otpData)) {\n        return {\n            valid: false,\n            error: \"Too many attempts. Please request a new OTP.\"\n        };\n    }\n    // Validate OTP\n    if (inputOTP === otpData.otp) {\n        return {\n            valid: true\n        };\n    }\n    return {\n        valid: false,\n        error: \"Invalid OTP. Please try again.\"\n    };\n}\n/**\r\n * Format phone number for display (mask middle digits)\r\n */ function maskPhoneNumber(phone) {\n    if (phone.length < 6) return phone;\n    const start = phone.slice(0, 4);\n    const end = phone.slice(-2);\n    const middle = \"*\".repeat(phone.length - 6);\n    return \"\".concat(start).concat(middle).concat(end);\n}\n/**\r\n * Format email for display (mask middle)\r\n */ function maskEmail(email) {\n    const [localPart, domain] = email.split(\"@\");\n    if (!domain) return email;\n    if (localPart.length <= 2) {\n        return \"\".concat(localPart, \"***@\").concat(domain);\n    }\n    const start = localPart.slice(0, 2);\n    const end = localPart.slice(-1);\n    return \"\".concat(start, \"***\").concat(end, \"@\").concat(domain);\n}\n/**\r\n * Calculate time remaining until OTP expires\r\n */ function getTimeRemaining(expiresAt) {\n    const remaining = Math.max(0, expiresAt - Date.now());\n    const minutes = Math.floor(remaining / 60000);\n    const seconds = Math.floor(remaining % 60000 / 1000);\n    return {\n        minutes,\n        seconds\n    };\n}\n/**\r\n * Format time remaining as string\r\n */ function formatTimeRemaining(expiresAt) {\n    const { minutes, seconds } = getTimeRemaining(expiresAt);\n    return \"\".concat(minutes, \":\").concat(seconds.toString().padStart(2, \"0\"));\n}\n/**\r\n * Simulate sending OTP via SMS\r\n * In production, integrate with SMS provider\r\n */ async function sendOTPViaSMS(phone, otp) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    if (OTP_CONFIG.demoMode) {\n        console.log(\"[DEMO] OTP \".concat(otp, \" sent to \").concat(phone));\n        return {\n            success: true,\n            message: \"OTP sent to \".concat(maskPhoneNumber(phone), \". Demo OTP: \").concat(OTP_CONFIG.demoOTP)\n        };\n    }\n    // In production, call SMS API here\n    // Example: await twilioClient.messages.create({ to: phone, body: `Your OTP is ${otp}` })\n    return {\n        success: true,\n        message: \"OTP sent to \".concat(maskPhoneNumber(phone))\n    };\n}\n/**\r\n * Simulate sending OTP via Email\r\n * In production, integrate with email provider\r\n */ async function sendOTPViaEmail(email, otp) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    if (OTP_CONFIG.demoMode) {\n        console.log(\"[DEMO] OTP \".concat(otp, \" sent to \").concat(email));\n        return {\n            success: true,\n            message: \"OTP sent to \".concat(maskEmail(email), \". Demo OTP: \").concat(OTP_CONFIG.demoOTP)\n        };\n    }\n    // In production, call email API here\n    return {\n        success: true,\n        message: \"OTP sent to \".concat(maskEmail(email))\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi91dGlscy9vdHAudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBY0Qsb0JBQW9CO0FBQ2IsTUFBTUEsYUFBYTtJQUN4QkMsUUFBUTtJQUNSQyxlQUFlO0lBQ2ZDLGFBQWE7SUFDYkMsdUJBQXVCO0lBQ3ZCLDBDQUEwQztJQUMxQ0MsVUFBVTtJQUNWLHVCQUF1QjtJQUN2QkMsU0FBUztBQUNYLEVBQUM7QUFFRDs7Q0FFQyxHQUNNLFNBQVNDO1FBQVlOLFNBQUFBLGlFQUFpQkQsV0FBV0MsTUFBTTtJQUM1RCxJQUFJRCxXQUFXSyxRQUFRLEVBQUU7UUFDdkIsT0FBT0wsV0FBV00sT0FBTztJQUMzQjtJQUVBLElBQUlFLE1BQU07SUFDVixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVIsUUFBUVEsSUFBSztRQUMvQkQsT0FBT0UsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssSUFBSUMsUUFBUTtJQUNoRDtJQUNBLE9BQU9MO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNNLGNBQ2RDLE9BQXdCLEVBQ3hCQyxVQUFrQixFQUNsQkMsT0FBMkI7SUFFM0IsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztJQUNwQixPQUFPO1FBQ0xWLEtBQUtEO1FBQ0xhLE9BQU9MLFlBQVksUUFBUUMsYUFBYUs7UUFDeENDLE9BQU9QLFlBQVksVUFBVUMsYUFBYUs7UUFDMUNOO1FBQ0FRLFdBQVdMO1FBQ1hNLFdBQVdOLE1BQU1sQixXQUFXRSxhQUFhLEdBQUcsS0FBSztRQUNqRHVCLFVBQVU7UUFDVkMsVUFBVTtRQUNWVDtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNVLGFBQWFDLE9BQWdCO0lBQzNDLE9BQU9ULEtBQUtELEdBQUcsS0FBS1UsUUFBUUosU0FBUztBQUN2QztBQUVBOztDQUVDLEdBQ00sU0FBU0ssc0JBQXNCRCxPQUFnQjtJQUNwRCxPQUFPQSxRQUFRSCxRQUFRLElBQUl6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SUFDMUM7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLGVBQWV1QyxnQkFDcEJyQyxLQUFhLEVBQ2JkLEdBQVc7SUFFWCxxQkFBcUI7SUFDckIsTUFBTSxJQUFJNEMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztJQUVqRCxJQUFJckQsV0FBV0ssUUFBUSxFQUFFO1FBQ3ZCa0QsUUFBUUMsR0FBRyxDQUFDLGNBQTZCbEMsT0FBZmQsS0FBSSxhQUFpQixPQUFOYztRQUN6QyxPQUFPO1lBQ0xtQyxTQUFTO1lBQ1RDLFNBQVMsZUFBOEMxRCxPQUEvQndDLFVBQVVsQixRQUFPLGdCQUFpQyxPQUFuQnRCLFdBQVdNLE9BQU87UUFDM0U7SUFDRjtJQUVBLHFDQUFxQztJQUVyQyxPQUFPO1FBQ0xtRCxTQUFTO1FBQ1RDLFNBQVMsZUFBZ0MsT0FBakJsQixVQUFVbEI7SUFDcEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdXRpbHMvb3RwLnRzPzdlNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE9UUCBVdGlsaXR5IFNlcnZpY2VcclxuICogSGFuZGxlcyBPVFAgZ2VuZXJhdGlvbiwgdmFsaWRhdGlvbiwgYW5kIG1hbmFnZW1lbnRcclxuICogXHJcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggU01TL0VtYWlsIHByb3ZpZGVycyBsaWtlOlxyXG4gKiAtIFR3aWxpbywgTVNHOTEsIEZpcmViYXNlIEF1dGgsIEFXUyBTTlNcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9UUERhdGEge1xyXG4gIG90cDogc3RyaW5nXHJcbiAgcGhvbmU/OiBzdHJpbmdcclxuICBlbWFpbD86IHN0cmluZ1xyXG4gIGNoYW5uZWw6ICdzbXMnIHwgJ2VtYWlsJ1xyXG4gIGNyZWF0ZWRBdDogbnVtYmVyXHJcbiAgZXhwaXJlc0F0OiBudW1iZXJcclxuICBhdHRlbXB0czogbnVtYmVyXHJcbiAgdmVyaWZpZWQ6IGJvb2xlYW5cclxuICBwdXJwb3NlOiAnbG9naW4nIHwgJ3JlZ2lzdGVyJyB8ICdyZXNldC1wYXNzd29yZCcgfCAndmVyaWZ5LXBob25lJyB8ICd2ZXJpZnktZW1haWwnXHJcbn1cclxuXHJcbi8vIE9UUCBDb25maWd1cmF0aW9uXHJcbmV4cG9ydCBjb25zdCBPVFBfQ09ORklHID0ge1xyXG4gIGxlbmd0aDogNixcclxuICBleHBpcnlNaW51dGVzOiA1LFxyXG4gIG1heEF0dGVtcHRzOiAzLFxyXG4gIHJlc2VuZENvb2xkb3duU2Vjb25kczogMzAsXHJcbiAgLy8gRGVtbyBtb2RlIC0gaW4gcHJvZHVjdGlvbiwgc2V0IHRvIGZhbHNlXHJcbiAgZGVtb01vZGU6IHRydWUsXHJcbiAgLy8gRGVtbyBPVFAgZm9yIHRlc3RpbmdcclxuICBkZW1vT1RQOiAnMTIzNDU2JyxcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIG51bWVyaWMgT1RQXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVPVFAobGVuZ3RoOiBudW1iZXIgPSBPVFBfQ09ORklHLmxlbmd0aCk6IHN0cmluZyB7XHJcbiAgaWYgKE9UUF9DT05GSUcuZGVtb01vZGUpIHtcclxuICAgIHJldHVybiBPVFBfQ09ORklHLmRlbW9PVFBcclxuICB9XHJcbiAgXHJcbiAgbGV0IG90cCA9ICcnXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgb3RwICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygpXHJcbiAgfVxyXG4gIHJldHVybiBvdHBcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBPVFAgZGF0YSBvYmplY3Qgd2l0aCBleHBpcnlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPVFBEYXRhKFxyXG4gIGNoYW5uZWw6ICdzbXMnIHwgJ2VtYWlsJyxcclxuICBpZGVudGlmaWVyOiBzdHJpbmcsXHJcbiAgcHVycG9zZTogT1RQRGF0YVsncHVycG9zZSddXHJcbik6IE9UUERhdGEge1xyXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KClcclxuICByZXR1cm4ge1xyXG4gICAgb3RwOiBnZW5lcmF0ZU9UUCgpLFxyXG4gICAgcGhvbmU6IGNoYW5uZWwgPT09ICdzbXMnID8gaWRlbnRpZmllciA6IHVuZGVmaW5lZCxcclxuICAgIGVtYWlsOiBjaGFubmVsID09PSAnZW1haWwnID8gaWRlbnRpZmllciA6IHVuZGVmaW5lZCxcclxuICAgIGNoYW5uZWwsXHJcbiAgICBjcmVhdGVkQXQ6IG5vdyxcclxuICAgIGV4cGlyZXNBdDogbm93ICsgT1RQX0NPTkZJRy5leHBpcnlNaW51dGVzICogNjAgKiAxMDAwLFxyXG4gICAgYXR0ZW1wdHM6IDAsXHJcbiAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICBwdXJwb3NlLFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIE9UUCBpcyBleHBpcmVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNPVFBFeHBpcmVkKG90cERhdGE6IE9UUERhdGEpOiBib29sZWFuIHtcclxuICByZXR1cm4gRGF0ZS5ub3coKSA+IG90cERhdGEuZXhwaXJlc0F0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBtYXggYXR0ZW1wdHMgZXhjZWVkZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc01heEF0dGVtcHRzRXhjZWVkZWQob3RwRGF0YTogT1RQRGF0YSk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBvdHBEYXRhLmF0dGVtcHRzID49IE9UUF9DT05GSUcubWF4QXR0ZW1wdHNcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIE9UUFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT1RQKFxyXG4gIGlucHV0T1RQOiBzdHJpbmcsXHJcbiAgb3RwRGF0YTogT1RQRGF0YVxyXG4pOiB7IHZhbGlkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9IHtcclxuICAvLyBDaGVjayBpZiBhbHJlYWR5IHZlcmlmaWVkXHJcbiAgaWYgKG90cERhdGEudmVyaWZpZWQpIHtcclxuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdPVFAgYWxyZWFkeSB1c2VkJyB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBleHBpcnlcclxuICBpZiAoaXNPVFBFeHBpcmVkKG90cERhdGEpKSB7XHJcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnT1RQIGhhcyBleHBpcmVkLiBQbGVhc2UgcmVxdWVzdCBhIG5ldyBvbmUuJyB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBhdHRlbXB0c1xyXG4gIGlmIChpc01heEF0dGVtcHRzRXhjZWVkZWQob3RwRGF0YSkpIHtcclxuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdUb28gbWFueSBhdHRlbXB0cy4gUGxlYXNlIHJlcXVlc3QgYSBuZXcgT1RQLicgfVxyXG4gIH1cclxuXHJcbiAgLy8gVmFsaWRhdGUgT1RQXHJcbiAgaWYgKGlucHV0T1RQID09PSBvdHBEYXRhLm90cCkge1xyXG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ0ludmFsaWQgT1RQLiBQbGVhc2UgdHJ5IGFnYWluLicgfVxyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IHBob25lIG51bWJlciBmb3IgZGlzcGxheSAobWFzayBtaWRkbGUgZGlnaXRzKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hc2tQaG9uZU51bWJlcihwaG9uZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBpZiAocGhvbmUubGVuZ3RoIDwgNikgcmV0dXJuIHBob25lXHJcbiAgY29uc3Qgc3RhcnQgPSBwaG9uZS5zbGljZSgwLCA0KVxyXG4gIGNvbnN0IGVuZCA9IHBob25lLnNsaWNlKC0yKVxyXG4gIGNvbnN0IG1pZGRsZSA9ICcqJy5yZXBlYXQocGhvbmUubGVuZ3RoIC0gNilcclxuICByZXR1cm4gYCR7c3RhcnR9JHttaWRkbGV9JHtlbmR9YFxyXG59XHJcblxyXG4vKipcclxuICogRm9ybWF0IGVtYWlsIGZvciBkaXNwbGF5IChtYXNrIG1pZGRsZSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXNrRW1haWwoZW1haWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgW2xvY2FsUGFydCwgZG9tYWluXSA9IGVtYWlsLnNwbGl0KCdAJylcclxuICBpZiAoIWRvbWFpbikgcmV0dXJuIGVtYWlsXHJcbiAgXHJcbiAgaWYgKGxvY2FsUGFydC5sZW5ndGggPD0gMikge1xyXG4gICAgcmV0dXJuIGAke2xvY2FsUGFydH0qKipAJHtkb21haW59YFxyXG4gIH1cclxuICBcclxuICBjb25zdCBzdGFydCA9IGxvY2FsUGFydC5zbGljZSgwLCAyKVxyXG4gIGNvbnN0IGVuZCA9IGxvY2FsUGFydC5zbGljZSgtMSlcclxuICByZXR1cm4gYCR7c3RhcnR9KioqJHtlbmR9QCR7ZG9tYWlufWBcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aW1lIHJlbWFpbmluZyB1bnRpbCBPVFAgZXhwaXJlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWVSZW1haW5pbmcoZXhwaXJlc0F0OiBudW1iZXIpOiB7IG1pbnV0ZXM6IG51bWJlcjsgc2Vjb25kczogbnVtYmVyIH0ge1xyXG4gIGNvbnN0IHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIGV4cGlyZXNBdCAtIERhdGUubm93KCkpXHJcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IocmVtYWluaW5nIC8gNjAwMDApXHJcbiAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IoKHJlbWFpbmluZyAlIDYwMDAwKSAvIDEwMDApXHJcbiAgcmV0dXJuIHsgbWludXRlcywgc2Vjb25kcyB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgdGltZSByZW1haW5pbmcgYXMgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VGltZVJlbWFpbmluZyhleHBpcmVzQXQ6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgY29uc3QgeyBtaW51dGVzLCBzZWNvbmRzIH0gPSBnZXRUaW1lUmVtYWluaW5nKGV4cGlyZXNBdClcclxuICByZXR1cm4gYCR7bWludXRlc306JHtzZWNvbmRzLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW11bGF0ZSBzZW5kaW5nIE9UUCB2aWEgU01TXHJcbiAqIEluIHByb2R1Y3Rpb24sIGludGVncmF0ZSB3aXRoIFNNUyBwcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRPVFBWaWFTTVMoXHJcbiAgcGhvbmU6IHN0cmluZyxcclxuICBvdHA6IHN0cmluZ1xyXG4pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZTogc3RyaW5nIH0+IHtcclxuICAvLyBTaW11bGF0ZSBBUEkgZGVsYXlcclxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXHJcbiAgXHJcbiAgaWYgKE9UUF9DT05GSUcuZGVtb01vZGUpIHtcclxuICAgIGNvbnNvbGUubG9nKGBbREVNT10gT1RQICR7b3RwfSBzZW50IHRvICR7cGhvbmV9YClcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIG1lc3NhZ2U6IGBPVFAgc2VudCB0byAke21hc2tQaG9uZU51bWJlcihwaG9uZSl9LiBEZW1vIE9UUDogJHtPVFBfQ09ORklHLmRlbW9PVFB9YCxcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gSW4gcHJvZHVjdGlvbiwgY2FsbCBTTVMgQVBJIGhlcmVcclxuICAvLyBFeGFtcGxlOiBhd2FpdCB0d2lsaW9DbGllbnQubWVzc2FnZXMuY3JlYXRlKHsgdG86IHBob25lLCBib2R5OiBgWW91ciBPVFAgaXMgJHtvdHB9YCB9KVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgbWVzc2FnZTogYE9UUCBzZW50IHRvICR7bWFza1Bob25lTnVtYmVyKHBob25lKX1gLFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbXVsYXRlIHNlbmRpbmcgT1RQIHZpYSBFbWFpbFxyXG4gKiBJbiBwcm9kdWN0aW9uLCBpbnRlZ3JhdGUgd2l0aCBlbWFpbCBwcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRPVFBWaWFFbWFpbChcclxuICBlbWFpbDogc3RyaW5nLFxyXG4gIG90cDogc3RyaW5nXHJcbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xyXG4gIC8vIFNpbXVsYXRlIEFQSSBkZWxheVxyXG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcclxuICBcclxuICBpZiAoT1RQX0NPTkZJRy5kZW1vTW9kZSkge1xyXG4gICAgY29uc29sZS5sb2coYFtERU1PXSBPVFAgJHtvdHB9IHNlbnQgdG8gJHtlbWFpbH1gKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogYE9UUCBzZW50IHRvICR7bWFza0VtYWlsKGVtYWlsKX0uIERlbW8gT1RQOiAke09UUF9DT05GSUcuZGVtb09UUH1gLFxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBJbiBwcm9kdWN0aW9uLCBjYWxsIGVtYWlsIEFQSSBoZXJlXHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICBtZXNzYWdlOiBgT1RQIHNlbnQgdG8gJHttYXNrRW1haWwoZW1haWwpfWAsXHJcbiAgfVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiT1RQX0NPTkZJRyIsImxlbmd0aCIsImV4cGlyeU1pbnV0ZXMiLCJtYXhBdHRlbXB0cyIsInJlc2VuZENvb2xkb3duU2Vjb25kcyIsImRlbW9Nb2RlIiwiZGVtb09UUCIsImdlbmVyYXRlT1RQIiwib3RwIiwiaSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwiY3JlYXRlT1RQRGF0YSIsImNoYW5uZWwiLCJpZGVudGlmaWVyIiwicHVycG9zZSIsIm5vdyIsIkRhdGUiLCJwaG9uZSIsInVuZGVmaW5lZCIsImVtYWlsIiwiY3JlYXRlZEF0IiwiZXhwaXJlc0F0IiwiYXR0ZW1wdHMiLCJ2ZXJpZmllZCIsImlzT1RQRXhwaXJlZCIsIm90cERhdGEiLCJpc01heEF0dGVtcHRzRXhjZWVkZWQiLCJ2YWxpZGF0ZU9UUCIsImlucHV0T1RQIiwidmFsaWQiLCJlcnJvciIsIm1hc2tQaG9uZU51bWJlciIsInN0YXJ0Iiwic2xpY2UiLCJlbmQiLCJtaWRkbGUiLCJyZXBlYXQiLCJtYXNrRW1haWwiLCJsb2NhbFBhcnQiLCJkb21haW4iLCJzcGxpdCIsImdldFRpbWVSZW1haW5pbmciLCJyZW1haW5pbmciLCJtYXgiLCJtaW51dGVzIiwic2Vjb25kcyIsImZvcm1hdFRpbWVSZW1haW5pbmciLCJwYWRTdGFydCIsInNlbmRPVFBWaWFTTVMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjb25zb2xlIiwibG9nIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJzZW5kT1RQVmlhRW1haWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils/otp.ts\n"));

/***/ })

});