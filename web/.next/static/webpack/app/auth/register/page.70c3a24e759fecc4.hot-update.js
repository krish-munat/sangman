"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/auth/register/page",{

/***/ "(app-pages-browser)/./lib/utils/otp.ts":
/*!**************************!*\
  !*** ./lib/utils/otp.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OTP_CONFIG: function() { return /* binding */ OTP_CONFIG; },\n/* harmony export */   createOTPData: function() { return /* binding */ createOTPData; },\n/* harmony export */   formatTimeRemaining: function() { return /* binding */ formatTimeRemaining; },\n/* harmony export */   generateOTP: function() { return /* binding */ generateOTP; },\n/* harmony export */   getTimeRemaining: function() { return /* binding */ getTimeRemaining; },\n/* harmony export */   isMaxAttemptsExceeded: function() { return /* binding */ isMaxAttemptsExceeded; },\n/* harmony export */   isOTPExpired: function() { return /* binding */ isOTPExpired; },\n/* harmony export */   maskEmail: function() { return /* binding */ maskEmail; },\n/* harmony export */   maskPhoneNumber: function() { return /* binding */ maskPhoneNumber; },\n/* harmony export */   sendOTPViaEmail: function() { return /* binding */ sendOTPViaEmail; },\n/* harmony export */   sendOTPViaSMS: function() { return /* binding */ sendOTPViaSMS; },\n/* harmony export */   validateOTP: function() { return /* binding */ validateOTP; }\n/* harmony export */ });\n/**\r\n * OTP Utility Service\r\n * Handles OTP generation, validation, and management\r\n * \r\n * In production, this would integrate with SMS/Email providers like:\r\n * - Twilio, MSG91, Firebase Auth, AWS SNS\r\n */ // OTP Configuration\nconst OTP_CONFIG = {\n    length: 6,\n    expiryMinutes: 5,\n    maxAttempts: 3,\n    resendCooldownSeconds: 30,\n    // Demo mode - in production, set to false\n    demoMode: true,\n    // Demo OTP for testing\n    demoOTP: \"123456\"\n};\n/**\r\n * Generate a random numeric OTP\r\n */ function generateOTP() {\n    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OTP_CONFIG.length;\n    if (OTP_CONFIG.demoMode) {\n        return OTP_CONFIG.demoOTP;\n    }\n    let otp = \"\";\n    for(let i = 0; i < length; i++){\n        otp += Math.floor(Math.random() * 10).toString();\n    }\n    return otp;\n}\n/**\r\n * Create OTP data object with expiry\r\n */ function createOTPData(phone, purpose, email) {\n    const now = Date.now();\n    return {\n        otp: generateOTP(),\n        phone,\n        email,\n        createdAt: now,\n        expiresAt: now + OTP_CONFIG.expiryMinutes * 60 * 1000,\n        attempts: 0,\n        verified: false,\n        purpose\n    };\n}\n/**\r\n * Check if OTP is expired\r\n */ function isOTPExpired(otpData) {\n    return Date.now() > otpData.expiresAt;\n}\n/**\r\n * Check if max attempts exceeded\r\n */ function isMaxAttemptsExceeded(otpData) {\n    return otpData.attempts >= OTP_CONFIG.maxAttempts;\n}\n/**\r\n * Validate OTP\r\n */ function validateOTP(inputOTP, otpData) {\n    // Check if already verified\n    if (otpData.verified) {\n        return {\n            valid: false,\n            error: \"OTP already used\"\n        };\n    }\n    // Check expiry\n    if (isOTPExpired(otpData)) {\n        return {\n            valid: false,\n            error: \"OTP has expired. Please request a new one.\"\n        };\n    }\n    // Check attempts\n    if (isMaxAttemptsExceeded(otpData)) {\n        return {\n            valid: false,\n            error: \"Too many attempts. Please request a new OTP.\"\n        };\n    }\n    // Validate OTP\n    if (inputOTP === otpData.otp) {\n        return {\n            valid: true\n        };\n    }\n    return {\n        valid: false,\n        error: \"Invalid OTP. Please try again.\"\n    };\n}\n/**\r\n * Format phone number for display (mask middle digits)\r\n */ function maskPhoneNumber(phone) {\n    if (phone.length < 6) return phone;\n    const start = phone.slice(0, 4);\n    const end = phone.slice(-2);\n    const middle = \"*\".repeat(phone.length - 6);\n    return \"\".concat(start).concat(middle).concat(end);\n}\n/**\r\n * Format email for display (mask middle)\r\n */ function maskEmail(email) {\n    const [localPart, domain] = email.split(\"@\");\n    if (!domain) return email;\n    if (localPart.length <= 2) {\n        return \"\".concat(localPart, \"***@\").concat(domain);\n    }\n    const start = localPart.slice(0, 2);\n    const end = localPart.slice(-1);\n    return \"\".concat(start, \"***\").concat(end, \"@\").concat(domain);\n}\n/**\r\n * Calculate time remaining until OTP expires\r\n */ function getTimeRemaining(expiresAt) {\n    const remaining = Math.max(0, expiresAt - Date.now());\n    const minutes = Math.floor(remaining / 60000);\n    const seconds = Math.floor(remaining % 60000 / 1000);\n    return {\n        minutes,\n        seconds\n    };\n}\n/**\r\n * Format time remaining as string\r\n */ function formatTimeRemaining(expiresAt) {\n    const { minutes, seconds } = getTimeRemaining(expiresAt);\n    return \"\".concat(minutes, \":\").concat(seconds.toString().padStart(2, \"0\"));\n}\n/**\r\n * Simulate sending OTP via SMS\r\n * In production, integrate with SMS provider\r\n */ async function sendOTPViaSMS(phone, otp) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    if (OTP_CONFIG.demoMode) {\n        console.log(\"[DEMO] OTP \".concat(otp, \" sent to \").concat(phone));\n        return {\n            success: true,\n            message: \"OTP sent to \".concat(maskPhoneNumber(phone), \". Demo OTP: \").concat(OTP_CONFIG.demoOTP)\n        };\n    }\n    // In production, call SMS API here\n    // Example: await twilioClient.messages.create({ to: phone, body: `Your OTP is ${otp}` })\n    return {\n        success: true,\n        message: \"OTP sent to \".concat(maskPhoneNumber(phone))\n    };\n}\n/**\r\n * Simulate sending OTP via Email\r\n * In production, integrate with email provider\r\n */ async function sendOTPViaEmail(email, otp) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    if (OTP_CONFIG.demoMode) {\n        console.log(\"[DEMO] OTP \".concat(otp, \" sent to \").concat(email));\n        return {\n            success: true,\n            message: \"OTP sent to \".concat(maskEmail(email), \". Demo OTP: \").concat(OTP_CONFIG.demoOTP)\n        };\n    }\n    // In production, call email API here\n    return {\n        success: true,\n        message: \"OTP sent to \".concat(maskEmail(email))\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi91dGlscy9vdHAudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBY0Qsb0JBQW9CO0FBQ2IsTUFBTUEsYUFBYTtJQUN4QkMsUUFBUTtJQUNSQyxlQUFlO0lBQ2ZDLGFBQWE7SUFDYkMsdUJBQXVCO0lBQ3ZCLDBDQUEwQztJQUMxQ0MsVUFBVTtJQUNWLHVCQUF1QjtJQUN2QkMsU0FBUztBQUNYLEVBQUM7QUFFRDs7Q0FFQyxHQUNNLFNBQVNDO1FBQVlOLFNBQUFBLGlFQUFpQkQsV0FBV0MsTUFBTTtJQUM1RCxJQUFJRCxXQUFXSyxRQUFRLEVBQUU7UUFDdkIsT0FBT0wsV0FBV00sT0FBTztJQUMzQjtJQUVBLElBQUlFLE1BQU07SUFDVixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVIsUUFBUVEsSUFBSztRQUMvQkQsT0FBT0UsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssSUFBSUMsUUFBUTtJQUNoRDtJQUNBLE9BQU9MO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNNLGNBQ2RDLEtBQWEsRUFDYkMsT0FBMkIsRUFDM0JDLEtBQWM7SUFFZCxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO0lBQ3BCLE9BQU87UUFDTFYsS0FBS0Q7UUFDTFE7UUFDQUU7UUFDQUcsV0FBV0Y7UUFDWEcsV0FBV0gsTUFBTWxCLFdBQVdFLGFBQWEsR0FBRyxLQUFLO1FBQ2pEb0IsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZQO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU1EsYUFBYUMsT0FBZ0I7SUFDM0MsT0FBT04sS0FBS0QsR0FBRyxLQUFLTyxRQUFRSixTQUFTO0FBQ3ZDO0FBRUE7O0NBRUMsR0FDTSxTQUFTSyxzQkFBc0JELE9BQWdCO0lBQ3BELE9BQU9BLFFBQVFILFFBQVEsSUFBSXRCLFdBQVdHLFdBQVc7QUFDbkQ7QUFFQTs7Q0FFQyxHQUNNLFNBQVN3QixZQUNkQyxRQUFnQixFQUNo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QVc7SUFFWCxxQkFBcUI7SUFDckIsTUFBTSxJQUFJeUMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztJQUVqRCxJQUFJbEQsV0FBV0ssUUFBUSxFQUFFO1FBQ3ZCK0MsUUFBUUMsR0FBRyxDQUFDLGNBQTZCcEMsT0FBZlQsS0FBSSxhQUFpQixPQUFOUztRQUN6QyxPQUFPO1lBQ0xxQyxTQUFTO1lBQ1RDLFNBQVMsZUFBOEN2RCxPQUEvQnFDLFVBQVVwQixRQUFPLGdCQUFpQyxPQUFuQmpCLFdBQVdNLE9BQU87UUFDM0U7SUFDRjtJQUVBLHFDQUFxQztJQUVyQyxPQUFPO1FBQ0xnRCxTQUFTO1FBQ1RDLFNBQVMsZUFBZ0MsT0FBakJsQixVQUFVcEI7SUFDcEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvdXRpbHMvb3RwLnRzPzdlNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE9UUCBVdGlsaXR5IFNlcnZpY2VcclxuICogSGFuZGxlcyBPVFAgZ2VuZXJhdGlvbiwgdmFsaWRhdGlvbiwgYW5kIG1hbmFnZW1lbnRcclxuICogXHJcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggU01TL0VtYWlsIHByb3ZpZGVycyBsaWtlOlxyXG4gKiAtIFR3aWxpbywgTVNHOTEsIEZpcmViYXNlIEF1dGgsIEFXUyBTTlNcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9UUERhdGEge1xyXG4gIG90cDogc3RyaW5nXHJcbiAgcGhvbmU/OiBzdHJpbmdcclxuICBlbWFpbD86IHN0cmluZ1xyXG4gIGNoYW5uZWw6ICdzbXMnIHwgJ2VtYWlsJ1xyXG4gIGNyZWF0ZWRBdDogbnVtYmVyXHJcbiAgZXhwaXJlc0F0OiBudW1iZXJcclxuICBhdHRlbXB0czogbnVtYmVyXHJcbiAgdmVyaWZpZWQ6IGJvb2xlYW5cclxuICBwdXJwb3NlOiAnbG9naW4nIHwgJ3JlZ2lzdGVyJyB8ICdyZXNldC1wYXNzd29yZCcgfCAndmVyaWZ5LXBob25lJyB8ICd2ZXJpZnktZW1haWwnXHJcbn1cclxuXHJcbi8vIE9UUCBDb25maWd1cmF0aW9uXHJcbmV4cG9ydCBjb25zdCBPVFBfQ09ORklHID0ge1xyXG4gIGxlbmd0aDogNixcclxuICBleHBpcnlNaW51dGVzOiA1LFxyXG4gIG1heEF0dGVtcHRzOiAzLFxyXG4gIHJlc2VuZENvb2xkb3duU2Vjb25kczogMzAsXHJcbiAgLy8gRGVtbyBtb2RlIC0gaW4gcHJvZHVjdGlvbiwgc2V0IHRvIGZhbHNlXHJcbiAgZGVtb01vZGU6IHRydWUsXHJcbiAgLy8gRGVtbyBPVFAgZm9yIHRlc3RpbmdcclxuICBkZW1vT1RQOiAnMTIzNDU2JyxcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIG51bWVyaWMgT1RQXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVPVFAobGVuZ3RoOiBudW1iZXIgPSBPVFBfQ09ORklHLmxlbmd0aCk6IHN0cmluZyB7XHJcbiAgaWYgKE9UUF9DT05GSUcuZGVtb01vZGUpIHtcclxuICAgIHJldHVybiBPVFBfQ09ORklHLmRlbW9PVFBcclxuICB9XHJcbiAgXHJcbiAgbGV0IG90cCA9ICcnXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgb3RwICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygpXHJcbiAgfVxyXG4gIHJldHVybiBvdHBcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBPVFAgZGF0YSBvYmplY3Qgd2l0aCBleHBpcnlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPVFBEYXRhKFxyXG4gIHBob25lOiBzdHJpbmcsXHJcbiAgcHVycG9zZTogT1RQRGF0YVsncHVycG9zZSddLFxyXG4gIGVtYWlsPzogc3RyaW5nXHJcbik6IE9UUERhdGEge1xyXG4gIGNvbnN0IG5vdyA9IERhdGUubm93KClcclxuICByZXR1cm4ge1xyXG4gICAgb3RwOiBnZW5lcmF0ZU9UUCgpLFxyXG4gICAgcGhvbmUsXHJcbiAgICBlbWFpbCxcclxuICAgIGNyZWF0ZWRBdDogbm93LFxyXG4gICAgZXhwaXJlc0F0OiBub3cgKyBPVFBfQ09ORklHLmV4cGlyeU1pbnV0ZXMgKiA2MCAqIDEwMDAsXHJcbiAgICBhdHRlbXB0czogMCxcclxuICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgIHB1cnBvc2UsXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgT1RQIGlzIGV4cGlyZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09UUEV4cGlyZWQob3RwRGF0YTogT1RQRGF0YSk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBEYXRlLm5vdygpID4gb3RwRGF0YS5leHBpcmVzQXRcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIG1heCBhdHRlbXB0cyBleGNlZWRlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTWF4QXR0ZW1wdHNFeGNlZWRlZChvdHBEYXRhOiBPVFBEYXRhKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIG90cERhdGEuYXR0ZW1wdHMgPj0gT1RQX0NPTkZJRy5tYXhBdHRlbXB0c1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgT1RQXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPVFAoXHJcbiAgaW5wdXRPVFA6IHN0cmluZyxcclxuICBvdHBEYXRhOiBPVFBEYXRhXHJcbik6IHsgdmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xyXG4gIC8vIENoZWNrIGlmIGFscmVhZHkgdmVyaWZpZWRcclxuICBpZiAob3RwRGF0YS52ZXJpZmllZCkge1xyXG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ09UUCBhbHJlYWR5IHVzZWQnIH1cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGV4cGlyeVxyXG4gIGlmIChpc09UUEV4cGlyZWQob3RwRGF0YSkpIHtcclxuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdPVFAgaGFzIGV4cGlyZWQuIFBsZWFzZSByZXF1ZXN0IGEgbmV3IG9uZS4nIH1cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGF0dGVtcHRzXHJcbiAgaWYgKGlzTWF4QXR0ZW1wdHNFeGNlZWRlZChvdHBEYXRhKSkge1xyXG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogJ1RvbyBtYW55IGF0dGVtcHRzLiBQbGVhc2UgcmVxdWVzdCBhIG5ldyBPVFAuJyB9XHJcbiAgfVxyXG5cclxuICAvLyBWYWxpZGF0ZSBPVFBcclxuICBpZiAoaW5wdXRPVFAgPT09IG90cERhdGEub3RwKSB7XHJcbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBPVFAuIFBsZWFzZSB0cnkgYWdhaW4uJyB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgcGhvbmUgbnVtYmVyIGZvciBkaXNwbGF5IChtYXNrIG1pZGRsZSBkaWdpdHMpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFza1Bob25lTnVtYmVyKHBob25lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmIChwaG9uZS5sZW5ndGggPCA2KSByZXR1cm4gcGhvbmVcclxuICBjb25zdCBzdGFydCA9IHBob25lLnNsaWNlKDAsIDQpXHJcbiAgY29uc3QgZW5kID0gcGhvbmUuc2xpY2UoLTIpXHJcbiAgY29uc3QgbWlkZGxlID0gJyonLnJlcGVhdChwaG9uZS5sZW5ndGggLSA2KVxyXG4gIHJldHVybiBgJHtzdGFydH0ke21pZGRsZX0ke2VuZH1gXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgZW1haWwgZm9yIGRpc3BsYXkgKG1hc2sgbWlkZGxlKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hc2tFbWFpbChlbWFpbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBbbG9jYWxQYXJ0LCBkb21haW5dID0gZW1haWwuc3BsaXQoJ0AnKVxyXG4gIGlmICghZG9tYWluKSByZXR1cm4gZW1haWxcclxuICBcclxuICBpZiAobG9jYWxQYXJ0Lmxlbmd0aCA8PSAyKSB7XHJcbiAgICByZXR1cm4gYCR7bG9jYWxQYXJ0fSoqKkAke2RvbWFpbn1gXHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHN0YXJ0ID0gbG9jYWxQYXJ0LnNsaWNlKDAsIDIpXHJcbiAgY29uc3QgZW5kID0gbG9jYWxQYXJ0LnNsaWNlKC0xKVxyXG4gIHJldHVybiBgJHtzdGFydH0qKioke2VuZH1AJHtkb21haW59YFxyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIHRpbWUgcmVtYWluaW5nIHVudGlsIE9UUCBleHBpcmVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZVJlbWFpbmluZyhleHBpcmVzQXQ6IG51bWJlcik6IHsgbWludXRlczogbnVtYmVyOyBzZWNvbmRzOiBudW1iZXIgfSB7XHJcbiAgY29uc3QgcmVtYWluaW5nID0gTWF0aC5tYXgoMCwgZXhwaXJlc0F0IC0gRGF0ZS5ub3coKSlcclxuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihyZW1haW5pbmcgLyA2MDAwMClcclxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcigocmVtYWluaW5nICUgNjAwMDApIC8gMTAwMClcclxuICByZXR1cm4geyBtaW51dGVzLCBzZWNvbmRzIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCB0aW1lIHJlbWFpbmluZyBhcyBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lUmVtYWluaW5nKGV4cGlyZXNBdDogbnVtYmVyKTogc3RyaW5nIHtcclxuICBjb25zdCB7IG1pbnV0ZXMsIHNlY29uZHMgfSA9IGdldFRpbWVSZW1haW5pbmcoZXhwaXJlc0F0KVxyXG4gIHJldHVybiBgJHttaW51dGVzfToke3NlY29uZHMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWBcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbXVsYXRlIHNlbmRpbmcgT1RQIHZpYSBTTVNcclxuICogSW4gcHJvZHVjdGlvbiwgaW50ZWdyYXRlIHdpdGggU01TIHByb3ZpZGVyXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZE9UUFZpYVNNUyhcclxuICBwaG9uZTogc3RyaW5nLFxyXG4gIG90cDogc3RyaW5nXHJcbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xyXG4gIC8vIFNpbXVsYXRlIEFQSSBkZWxheVxyXG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcclxuICBcclxuICBpZiAoT1RQX0NPTkZJRy5kZW1vTW9kZSkge1xyXG4gICAgY29uc29sZS5sb2coYFtERU1PXSBPVFAgJHtvdHB9IHNlbnQgdG8gJHtwaG9uZX1gKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogYE9UUCBzZW50IHRvICR7bWFza1Bob25lTnVtYmVyKHBob25lKX0uIERlbW8gT1RQOiAke09UUF9DT05GSUcuZGVtb09UUH1gLFxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBJbiBwcm9kdWN0aW9uLCBjYWxsIFNNUyBBUEkgaGVyZVxyXG4gIC8vIEV4YW1wbGU6IGF3YWl0IHR3aWxpb0NsaWVudC5tZXNzYWdlcy5jcmVhdGUoeyB0bzogcGhvbmUsIGJvZHk6IGBZb3VyIE9UUCBpcyAke290cH1gIH0pXHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICBtZXNzYWdlOiBgT1RQIHNlbnQgdG8gJHttYXNrUGhvbmVOdW1iZXIocGhvbmUpfWAsXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2ltdWxhdGUgc2VuZGluZyBPVFAgdmlhIEVtYWlsXHJcbiAqIEluIHByb2R1Y3Rpb24sIGludGVncmF0ZSB3aXRoIGVtYWlsIHByb3ZpZGVyXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VuZE9UUFZpYUVtYWlsKFxyXG4gIGVtYWlsOiBzdHJpbmcsXHJcbiAgb3RwOiBzdHJpbmdcclxuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9PiB7XHJcbiAgLy8gU2ltdWxhdGUgQVBJIGRlbGF5XHJcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxyXG4gIFxyXG4gIGlmIChPVFBfQ09ORklHLmRlbW9Nb2RlKSB7XHJcbiAgICBjb25zb2xlLmxvZyhgW0RFTU9dIE9UUCAke290cH0gc2VudCB0byAke2VtYWlsfWApXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBtZXNzYWdlOiBgT1RQIHNlbnQgdG8gJHttYXNrRW1haWwoZW1haWwpfS4gRGVtbyBPVFA6ICR7T1RQX0NPTkZJRy5kZW1vT1RQfWAsXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEluIHByb2R1Y3Rpb24sIGNhbGwgZW1haWwgQVBJIGhlcmVcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgc3VjY2VzczogdHJ1ZSxcclxuICAgIG1lc3NhZ2U6IGBPVFAgc2VudCB0byAke21hc2tFbWFpbChlbWFpbCl9YCxcclxuICB9XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJPVFBfQ09ORklHIiwibGVuZ3RoIiwiZXhwaXJ5TWludXRlcyIsIm1heEF0dGVtcHRzIiwicmVzZW5kQ29vbGRvd25TZWNvbmRzIiwiZGVtb01vZGUiLCJkZW1vT1RQIiwiZ2VuZXJhdGVPVFAiLCJvdHAiLCJpIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJjcmVhdGVPVFBEYXRhIiwicGhvbmUiLCJwdXJwb3NlIiwiZW1haWwiLCJub3ciLCJEYXRlIiwiY3JlYXRlZEF0IiwiZXhwaXJlc0F0IiwiYXR0ZW1wdHMiLCJ2ZXJpZmllZCIsImlzT1RQRXhwaXJlZCIsIm90cERhdGEiLCJpc01heEF0dGVtcHRzRXhjZWVkZWQiLCJ2YWxpZGF0ZU9UUCIsImlucHV0T1RQIiwidmFsaWQiLCJlcnJvciIsIm1hc2tQaG9uZU51bWJlciIsInN0YXJ0Iiwic2xpY2UiLCJlbmQiLCJtaWRkbGUiLCJyZXBlYXQiLCJtYXNrRW1haWwiLCJsb2NhbFBhcnQiLCJkb21haW4iLCJzcGxpdCIsImdldFRpbWVSZW1haW5pbmciLCJyZW1haW5pbmciLCJtYXgiLCJtaW51dGVzIiwic2Vjb25kcyIsImZvcm1hdFRpbWVSZW1haW5pbmciLCJwYWRTdGFydCIsInNlbmRPVFBWaWFTTVMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjb25zb2xlIiwibG9nIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJzZW5kT1RQVmlhRW1haWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils/otp.ts\n"));

/***/ })

});